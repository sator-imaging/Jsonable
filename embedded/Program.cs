using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;

namespace Jsonable
{
    sealed class Program
    {
        public static int Main(string[] args)
        {
            EmbedResources(args);
            return 0;
        }

        static void EmbedResources(string[] args, [CallerFilePath] string? callerFilePath = null)
        {
            Console.WriteLine("Collecting C# files...");

            Dictionary<string, byte[]> csFiles = new Dictionary<string, byte[]>();
            string searchDirPath = Directory.GetCurrentDirectory();

            const string TargetDirName = "embedded";
            var dirName = Path.GetDirectoryName(searchDirPath);
            if (dirName != TargetDirName)
            {
                searchDirPath = Directory.Exists(TargetDirName)
                    ? Path.Combine(searchDirPath, TargetDirName)
                    : throw new DirectoryNotFoundException(TargetDirName);
            }

            // Search for all .cs files in the current directory and its subdirectories
            string[] files = Directory.GetFiles(searchDirPath, "*.cs", SearchOption.AllDirectories);

            const string FacadeFileName = "JSONABLE";
            byte[]? sharedContent = null;


            var thisFileName = Path.GetFileNameWithoutExtension(callerFilePath);
            foreach (string filePath in files)
            {
                var fileNameNoExt = Path.GetFileNameWithoutExtension(filePath);
                if (fileNameNoExt == thisFileName)
                {
                    continue;
                }
                else if (fileNameNoExt.Contains("AssemblyInfo", StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }
                else if (fileNameNoExt.Contains("Benchmark", StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }

                if (filePath.Contains(Path.DirectorySeparatorChar + "obj" + Path.DirectorySeparatorChar, StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }

                try
                {
                    byte[] fileContent = File.ReadAllBytes(filePath);

                    if (fileNameNoExt == FacadeFileName)
                    {
                        sharedContent = fileContent;
                    }

                    var relFilePath = Path.GetRelativePath(Directory.GetCurrentDirectory(), filePath);
                    csFiles.Add(relFilePath, fileContent);
                    Console.WriteLine($"Added: {relFilePath}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error reading file {filePath}: {ex.Message}");
                }
            }


            var sb = new StringBuilder();
            sb.Append(
@"namespace Jsonable.Core
{
    internal static class Embedded
    {
"
            );

            foreach (var (filePath, content) in csFiles)
            {
                sb.Append(
$@"        public const string {Path.GetFileNameWithoutExtension(filePath)}
=
@""{Encoding.UTF8.GetString(content).Replace("\"", "\"\"", StringComparison.Ordinal)}""
;
"
                );
            }

            sb.Append(
@"
    }
}
"
            );


            if (!args.Contains("-q") &&
                !args.Contains("--quiet"))
            {
                Console.WriteLine(sb.ToString());
            }

            Console.WriteLine($"Found {csFiles.Count} files.");
            Console.WriteLine();

            if (sharedContent == null)
            {
                throw new FileNotFoundException(FacadeFileName);
            }

            string AUTOGEN_TAG =
$@"// <auto-generated>
//   {Path.GetRelativePath(Directory.GetCurrentDirectory(), callerFilePath ?? string.Empty).Replace('\\', '/')}
//   --> {string.Join("\n//   --> ", csFiles.Select(x => x.Key.Replace('\\', '/')))}
// </auto-generated>

"
            .Replace("\r", string.Empty);

            WriteFile(args, GetOutputFilePath("Embedded." + FacadeFileName + ".g.cs"), AUTOGEN_TAG + Encoding.UTF8.GetString(sharedContent));
            WriteFile(args, GetOutputFilePath("Embedded.g.cs"), AUTOGEN_TAG + sb.ToString());
        }

        static string GetOutputFilePath(string outputFileName)
        {
            const string OutputDirPath = "src/Core";
            var outputDirPath = Directory.GetCurrentDirectory().Replace('\\', '/') + '/' + OutputDirPath;

            if (!Directory.Exists(outputDirPath))
            {
                throw new DirectoryNotFoundException(outputDirPath);
            }

            var outputFilePath = outputDirPath + '/' + outputFileName;
            return Path.GetRelativePath(Directory.GetCurrentDirectory(), outputFilePath);
        }

        static void WriteFile(string[] args, string filePath, string content)
        {
            var isFileExist = File.Exists(filePath);
            if (isFileExist)
            {
                using var reader = new StreamReader(filePath);

                var span = content.AsSpan();
                var changed = false;

                var newline = new char[] { '\r', '\n' };

                string? line;
                while ((line = reader.ReadLine()) != null)
                {
                    if (!line.AsSpan().SequenceEqual(span.Slice(0, line.Length)))
                    {
                        changed = true;
                        break;
                    }

                    span = span.Slice(line.Length).TrimStart(newline);
                }

                if (!changed)
                {
                    Console.WriteLine($"Up to date: {filePath}");
                    return;
                }
            }

            if (!args.Contains("-f") &&
                !args.Contains("--force") &&
                isFileExist)
            {
                Console.Write($"Overwrite? {filePath} [N/y]: ");

                var read = Console.ReadKey(intercept: true);
                if (read.Key != ConsoleKey.Y)
                {
                    Console.WriteLine("...canceled");
                    return;
                }
            }

            File.WriteAllText(filePath, content);
            Console.WriteLine($"File written: {filePath}");
        }
    }
}
