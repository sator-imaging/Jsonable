// <auto-generated>
//   embedded/Program.cs
//   --> embedded/FromJsonHelpers.cs
//   --> embedded/JSONABLE.cs
//   --> embedded/ToJsonHelpers.cs
// </auto-generated>

namespace Jsonable.Core
{
    internal static class Embedded
    {
        public const string FromJsonHelpers
=
@"#if DEBUG
//#define __printf_debug__TryGetNext
//#define __printf_debug__TakeCollectionSizeOrNegative
//#define __printf_debug__TakeString
//#define __printf_debug__TakeStringBytes
//#define __printf_debug__Skip
#endif

using System;
using System.Buffers;
using System.Buffers.Binary;
using System.Buffers.Text;
using System.Runtime.InteropServices;

#nullable enable

namespace Jsonable
{
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false)]
    internal sealed class FromJsonAttribute : Attribute
    {
        public bool IncludeInternals { get; set; }
        public bool ExcludeInherited { get; set; }
    }

    internal static class FromJsonHelpers
    {
        public enum ItemType : short  // no Flags attribute
        {
            // NOTE: some logic is depending on the underlying value
            Error        /**/ = short.MinValue,  // 0b_1000...
            Unknown      /**/ = 0,
            EndOfStream  /**/ = 1,

            Key        /**/ = 1 << 1,
            String     /**/ = 1 << 2,
            Number     /**/ = 1 << 3,
            Object     /**/ = 1 << 4,
            Array      /**/ = 1 << 5,
            Boolean    /**/ = 1 << 6,
            Null       /**/ = 1 << 7,
            Map        /**/ = 1 << 8,
            Metadata   /**/ = 1 << 9,
            //EndOfObject = EndOfStream,
            EndOfArray /**/ = 1 << 10,
            EndOfMap   /**/ = 1 << 11,

            // combined flags
            AnyOfExitCondition = Error | EndOfStream,
            AnyOfString = Key | String,
            AnyOfCollection = Array | Map,
        }

        [StructLayout(LayoutKind.Auto)]
        public struct Parser
        {
            readonly int initialLength;
            ReadOnlyMemory<byte> json;
            ItemType mode;

            public Parser(ReadOnlyMemory<byte> json)
            {
                if (json.Length < JSONABLE.ObjectHeaderLength ||
                    JSONABLE.ObjectHeader_LE != BinaryPrimitives.ReadUInt64LittleEndian(json.Span))
                {
                    throw new ArgumentException(""Not a jsonable .jsonc stream"");
                }

                this.initialLength = json.Length;  // BEFORE slice

                json = json.Slice(JSONABLE.ObjectHeaderLength);

                this.json = json;
                this.mode = default;

                // Empty
                if (json.Length >= 2 &&
                    json.Span[0] == '{' &&
                    json.Span[1] == '}')
                {
                    this.json = json.Slice(2);
                    this.mode = ItemType.EndOfStream;
                }
            }


            readonly
            public (int consumed, ItemType lastItem) GetStatus() => (initialLength - json.Length, mode);

            readonly public ReadOnlyMemory<byte> RawMemory => json;
            readonly public ReadOnlySpan<byte> RawSpan => json.Span;


            public bool TryGetNext(out ItemType foundType)
            {
                var mode = this.mode;
                var json = this.json;

                foundType = default;

#if __printf_debug__TryGetNext
                Console.Write($""  {mode,12}: "");
#endif

                var span = json.Span;
                if (span.Length == 0 || (mode & ItemType.AnyOfExitCondition) != 0)
                {
                    foundType = mode > ItemType.EndOfStream
                        ? ItemType.Error
                        : mode
                        ;
                    goto QUIT__DONT_FORGET_TO_SET_TYPE;
                }

                byte currentChar = span[0];

#if __printf_debug__TryGetNext
                Console.Write($""{(char)currentChar} --> "");
#endif

                // metadata switch
                // it must not advance stream!
                if (currentChar == (byte)'/')
                {
                    foundType = getItemType(span);
                    goto SUCCESS__DONT_FORGET_TO_SET_TYPE;

                    // not a hot path
                    static ItemType getItemType(ReadOnlySpan<byte> span)
                    {
                        // ok to skip length check

                        if (JSONABLE.ObjectHeader_LE == BinaryPrimitives.ReadUInt64LittleEndian(span))
                        {
                            return ItemType.Object;
                        }
                        else
                        {
                            var openChar = span[6];

                            if (openChar is (byte)'[')
                            {
                                return ItemType.Array;
                            }
                            else if (openChar is (byte)'{')
                            {
                                return ItemType.Map;
                            }

                            return ItemType.String;
                        }
                    }
                }

                // json switch
                // always advance!!
                json = json.Slice(1);
                span = span.Slice(1);

                switch (currentChar)
                {
                    case (byte)'{':
                        {
                            foundType = ItemType.Key;
                            goto SUCCESS__DONT_FORGET_TO_SET_TYPE;
                        }

                    case (byte)':':
                        {
                            // ok to skip length check

                            if (mode is ItemType.Key)
                            {
                                if (span[0] is (byte)'/')
                                {
                                    foundType = ItemType.Metadata;
                                    goto SUCCESS__DONT_FORGET_TO_SET_TYPE;
                                }
                                else
                                {
                                    var fourChars = BinaryPrimitives.ReadUInt32LittleEndian(span);

                                    if (fourChars is JSONABLE.NULL_LE)
                                    {
                                        foundType = ItemType.Null;
                                        goto SUCCESS__DONT_FORGET_TO_SET_TYPE;
                                    }
                                    else if (fourChars is JSONABLE.TRUE_LE or JSONABLE.FALSE_LE)
                                    {
                                        foundType = ItemType.Boolean;
                                        goto SUCCESS__DONT_FORGET_TO_SET_TYPE;
                                    }

                                    foundType = ItemType.Number;
                                    goto SUCCESS__DONT_FORGET_TO_SET_TYPE;
                                }
                            }
                        }
                        break;

                    case (byte)',':
                        {
                            foundType = (mode & ItemType.AnyOfCollection) != 0
                                ? mode
                                : ItemType.Key
                                ;
                            goto SUCCESS__DONT_FORGET_TO_SET_TYPE;
                        }

                    case (byte)']':
                        {
                            foundType = ItemType.EndOfArray;
                            goto SUCCESS__DONT_FORGET_TO_SET_TYPE;
                        }

                    case (byte)'}':
                        {
                            foundType = mode is ItemType.Map
                                ? ItemType.EndOfMap
                                : ItemType.EndOfStream
                                ;
                            goto QUIT__DONT_FORGET_TO_SET_TYPE;
                        }

                    default:
                        foundType = ItemType.Error;
                        goto QUIT__DONT_FORGET_TO_SET_TYPE;
                }

            SUCCESS__DONT_FORGET_TO_SET_TYPE:
#if __printf_debug__TryGetNext
                Console.WriteLine($""[SUCCESS] {foundType}"");
#endif
                this.json = json;
                this.mode = foundType;
                return true;

            QUIT__DONT_FORGET_TO_SET_TYPE:
#if __printf_debug__TryGetNext
                Console.WriteLine($""[QUIT] {foundType}"");
#endif
                this.json = json;
                this.mode = foundType;
                return false;
            }


            public int TakeCollectionSizeOrNegative()
            {
                var json = this.json;
                if (json.Span[0] is not (byte)'/')
                {
                    this.mode = ItemType.Error;
                    return -1;
                }

                // ummmm.....
                var mode = this.mode;
                if (mode is ItemType.Metadata)
                {
                    TryGetNext(out mode);
                }

                // ok to skip length check
                var length = JSONABLE.DecodeLengthUnsafe(json.Span.Slice(2, 2));

#if __printf_debug__TakeCollectionSizeOrNegative
                Console.WriteLine($""[{nameof(TakeCollectionSizeOrNegative)}] {length}"");
#endif

                json = json.Slice(6);

                this.json = json;
                return length;
            }


            public ReadOnlySpan<byte> TakeStringBytes()
            {
                var length = TakeCollectionSizeOrNegative();
                if (length < 0)
                {
                    this.mode = ItemType.Error;
                    return ReadOnlySpan<byte>.Empty;
                }

                var result = json.Span.Slice(1, length);  // skip leading ""
                this.json = json.Slice(length + 2);       // including quotes

#if __printf_debug__TakeStringBytes
                Console.WriteLine($""[{nameof(TakeStringBytes)}] {JSONABLE.GetVisibleString(result)}"");
#endif
                return result;
            }

            public string TakeString()
            {
                var length = TakeCollectionSizeOrNegative();
                if (length < 0)
                {
                    this.mode = ItemType.Error;
                    return string.Empty;
                }

                var result = json.Span.Slice(1, length);  // skip leading ""
                this.json = json.Slice(length + 2);       // including quotes

#if __printf_debug__TakeString
                Console.WriteLine($""[{nameof(TakeString)}] {JSONABLE.GetVisibleString(result)}"");
#endif

                return JSONABLE.UnescapeStringIfRequired(result);
            }


            public ReadOnlySpan<byte> Skip(int size)
            {
                var result = json.Span.Slice(0, size);
                this.json = json.Slice(size);

#if __printf_debug__Skip
                Console.WriteLine($""[{nameof(Skip)}] {size}"");
#endif
                return result;
            }


            public bool TryTakeNull()
            {
                if (json.Length >= 4)
                {
                    var value = BinaryPrimitives.ReadUInt32LittleEndian(json.Span);
                    if (value == JSONABLE.NULL_LE)
                    {
                        this.json = json.Slice(4);
                        return true;
                    }
                }

                return false;
            }


            public byte[] TakeBytesFromBase64(byte[]? current, bool reuseInstance)
            {
                var base64 = TakeStringBytes();

                var decodedLength = JSONABLE.GetBase64DecodedLength(base64);
                if (decodedLength < 0)
                {
                    goto FAILED;
                }

                var result = (reuseInstance && current?.Length == decodedLength) ? current : new byte[decodedLength];

                if (decodedLength > 0)
                {
                    var status = Base64.DecodeFromUtf8(base64, result, out _, out var written, isFinalBlock: true);
                    if (status != OperationStatus.Done ||
                        result.Length != written)
                    {
                        goto FAILED;
                    }
                }

                return result;

            FAILED:
                this.mode = ItemType.Error;
                return Array.Empty<byte>();
            }


            // ummmm.... this is required because it's hard to detect end of map of map/object
            // --> ""map"":{""key1"":{...},""key2"":{...}}  <-- ends with double '}'
            public void SetItemType(ItemType type)
            {
                this.mode = type;
            }
        }
    }
}
"
;
        public const string JSONABLE
=
@"// NOTE: this script file is included in analyzer build AND embedded in target assembly.
//       * some methods are not called in ANALYZER so it can be excluded from ANALYZER build.
//       * the following directive is resolved in target assembly because it is EMBEDDED.
//       * source generator in Unity runs on unknown environment so directive for Unity is required.
#if UNITY_2021_3_OR_NEWER || NETSTANDARD2_1_OR_GREATER || NET5_0_OR_GREATER
#define __supported
#endif

using System;
using System.Buffers;
using System.Buffers.Binary;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;

#nullable enable

namespace Jsonable
{
    internal sealed class JsonableException : Exception
    {
        JsonableException(string message, Exception? inner) : base(message, inner) { }

        [DoesNotReturn]
        public static void Throw(string message, Exception? inner = null) => throw new JsonableException(message, inner);

        [DoesNotReturn]
        public static void ThrowWithBufferPreview(string message, ReadOnlySpan<byte> bufferToPreview, Exception? inner = null)
        {
            var preview = JSONABLE.GetVisibleString(bufferToPreview.Slice(0, Math.Min(40, bufferToPreview.Length)));
            throw new JsonableException($""{message} (```{preview}```)"", inner);
        }
    }

    internal static class JSONABLE
    {
        // NOTE: in little endian
        //       - 1st char must be greater than '/' (can have UTF-8 lead byte)
        //       --> when emit .jsonc comment with random ushort value in /*{r}*/ format,
        //           need to avoid generating '/**/*/' and '/*/**/' unexpectedly.
        //       - 2nd char must be less than '0x7F' as 1st char may be UTF-8 lead byte
        //       --> if MSB is starting '10', it can be valid utf8 string.
        //       --> also, avoid null char (\0) in json by adding +1 always.
        public const int MetadataLengthOffset = 0x_01_30;  // 0x2A = '*', 0x2F = '/'
        public const int MetadataLengthMaxInclusive = 0x_7E_FF - MetadataLengthOffset;  // no 0x7F (DEL) at 2nd char

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ushort EncodeLengthUnsafe(int length)
        {
            // unsafe means no range check. not unchecked arithmetic.
            checked
            {
                return (ushort)(length + MetadataLengthOffset);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ushort DecodeLengthUnsafe(ReadOnlySpan<byte> bytes)
        {
            // unsafe means no range check. not unchecked arithmetic.
            checked
            {
                return (ushort)(BinaryPrimitives.ReadUInt16LittleEndian(bytes) - MetadataLengthOffset);
            }
        }


        public const int Base64MaxLength = (MetadataLengthMaxInclusive / 4 * 3);
        public const int MaxPossibleValueLength = 40;  // for value types without length metadata

        public const char DateTimeFormat = 'O';
        public const char GuidFormat = 'D';

        public static readonly UTF8Encoding Encoder = (UTF8Encoding)Encoding.UTF8;
        public static readonly byte[] NULL = new byte[] { (byte)'n', (byte)'u', (byte)'l', (byte)'l' };
        public static readonly byte[] TRUE = new byte[] { (byte)'t', (byte)'r', (byte)'u', (byte)'e' };
        public static readonly byte[] FALSE = new byte[] { (byte)'f', (byte)'a', (byte)'l', (byte)'s', (byte)'e' };
        public static readonly byte[] CommentOpen = new byte[] { (byte)'/', (byte)'*' };
        public static readonly byte[] CommentClose = new byte[] { (byte)'*', (byte)'/' };
        public static readonly byte[] ValueEndChars = new byte[] { (byte)',', (byte)'}', (byte)']' };
        public static readonly char[] EscapeTargets = new char[] { '""', '\\', '\n', '\t', '\r', /*'\b', '\f'*/ };

        public static readonly byte[] Utf8Bom = new byte[] { 0xEF, 0xBB, 0xBF };

        public static readonly byte[] ObjectHeader = new byte[] { (byte)'/', (byte)'*', (byte)'J', (byte)'M', (byte)'C', (byte)'1', (byte)'*', (byte)'/' };
        public const ulong ObjectHeader_LE
            = ((ulong)'/' << 0)
            | ((ulong)'*' << 8)
            | ((ulong)'J' << 16)
            | ((ulong)'M' << 24)
            | ((ulong)'C' << 32)
            | ((ulong)'1' << 40)
            | ((ulong)'*' << 48)
            | ((ulong)'/' << 56)
            ;
        public const int ObjectHeaderLength = 8;

        // literal detectors
        public const uint NULL_LE
            = ((uint)'n' << 0)
            | ((uint)'u' << 8)
            | ((uint)'l' << 16)
            | ((uint)'l' << 24)
            ;
        public const uint TRUE_LE
            = ((uint)'t' << 0)
            | ((uint)'r' << 8)
            | ((uint)'u' << 16)
            | ((uint)'e' << 24)
            ;
        public const uint FALSE_LE
            = ((uint)'f' << 0)
            | ((uint)'a' << 8)
            | ((uint)'l' << 16)
            | ((uint)'s' << 24)
            ;


        public static string GetVisibleString(ReadOnlySpan<byte> bytes)
        {
            return Encoder.GetString(bytes.ToArray().Where(x => x != '\0').ToArray());
        }


        /// <returns>The length of the decoded byte array, or -1 if the input length is invalid.</returns>
        public static int GetBase64DecodedLength(ReadOnlySpan<byte> base64Bytes)
        {
            int encodedLength = base64Bytes.Length;
            if (encodedLength == 0)
            {
                return 0;
            }
            else if (encodedLength < 4)
            {
                return -1;
            }

            int paddingCharCount = 0;
            if (base64Bytes[encodedLength - 1] == (byte)'=')
            {
                paddingCharCount++;
            }
            if (base64Bytes[encodedLength - 2] == (byte)'=')
            {
                paddingCharCount++;
            }

            // Each 4 chars represent 3 bytes, except for padding.
            // We assume valid Base64 input, so no need to check for invalid lengths.
            return (encodedLength / 4 * 3) - paddingCharCount;
        }


        // TODO: use SIMD function for string operation while keeping Unity compatibility

        #region   Escape/Unescape string

        volatile static WeakReference<StringBuilder>? interlock_sb;

        public static string EscapeStringIfRequired(string value)
        {
            // TODO: SIMD --> detect char code lower than or equal to 0x2F (control chars) and also \ and ""
            int targetIndex = value.IndexOfAny(EscapeTargets);
            if (targetIndex < 0)
            {
                return value;
            }

            var weakRef = Interlocked.Exchange(ref interlock_sb, null);
            if (weakRef == null || !weakRef.TryGetTarget(out var sb))  // don't simplify by using weakRef?.TryGetTarget (fix for Unity)
            {
                sb = new(capacity: value.Length * 2);
            }

            // NOTE: do not sanitize string here.
            //       invalid string issue must be addressed outside of this library.
            sb.Append(value);

            // NOTE: replace order is important!
            sb.Replace(""\\"", @""\\"", targetIndex, sb.Length - targetIndex);   // backslash
            sb.Replace(""\"""", @""\"""""", targetIndex, sb.Length - targetIndex);  // then quote
            sb.Replace(""\n"", @""\n"", targetIndex, sb.Length - targetIndex);   // and control chars
            sb.Replace(""\t"", @""\t"", targetIndex, sb.Length - targetIndex);
            sb.Replace(""\r"", @""\r"", targetIndex, sb.Length - targetIndex);

            var result = sb.ToString();
            sb.Length = 0;

            weakRef ??= new(sb);
            weakRef.SetTarget(sb);

            Interlocked.Exchange(ref interlock_sb, weakRef);

            return result;
        }

#if __supported
        public static string UnescapeStringIfRequired(ReadOnlySpan<byte> utf8)  // for .NET Standard 2.0; Encoding doesn't have span overload
        {
            if (utf8.Length == 0)
            {
                return string.Empty;
            }

            var value = Encoder.GetString(utf8);

            // checking utf8 bytes is faster, but index is required for efficient replacement.
            int targetIndex = value.IndexOf('\\');
            if (targetIndex < 0)
            {
                return value;
            }

            var weakRef = Interlocked.Exchange(ref interlock_sb, null);
            if (weakRef == null || !weakRef.TryGetTarget(out var sb))  // don't simplify by using weakRef?.TryGetTarget (fix for Unity)
            {
                sb = new(capacity: value.Length);
            }

            // NOTE: do not sanitize string here.
            //       invalid string issue must be addressed outside of this library.
            // TODO: avoid allocating new string instance
            sb.Append(value);

            // NOTE: replace order is important!
            sb.Replace(@""\n"", ""\n"", targetIndex, sb.Length - targetIndex);
            sb.Replace(@""\t"", ""\t"", targetIndex, sb.Length - targetIndex);
            sb.Replace(@""\r"", ""\r"", targetIndex, sb.Length - targetIndex);   // control chars
            sb.Replace(@""\"""""", ""\"""", targetIndex, sb.Length - targetIndex);  // then quote
            sb.Replace(@""\\"", ""\\"", targetIndex, sb.Length - targetIndex);   // and backslash

            var result = sb.ToString();
            sb.Length = 0;

            weakRef ??= new(sb);
            weakRef.SetTarget(sb);

            Interlocked.Exchange(ref interlock_sb, weakRef);

            return result;
        }
#endif

        #endregion


        #region   Stringify & Prettify
#if __supported

        public static Span<byte> CopySliceUnsafe(Span<byte> span, ReadOnlySpan<byte> value)
        {
            value.CopyTo(span);
            return span.Slice(value.Length);
        }

        public static Span<byte> CopySliceUnsafe(Span<byte> span, byte value, int count)
        {
            if (count == 1)
            {
                span[0] = value;
            }
            else
            {
                span.Slice(0, count).Fill(value);
            }

            return span.Slice(count);
        }


        public static string Stringify(ReadOnlyMemory<byte> utf8, int indentSize, char indentChar, ReadOnlySpan<char> newLine, bool prettyPrint)
        {
            if (prettyPrint)
            {
                var nl = (stackalloc byte[newLine.Length]);
                for (int i = 0; i < newLine.Length; i++)
                {
                    nl[i] = (byte)(newLine[i] & 0x7F);
                }

                utf8 = Prettify(writer: null, utf8, indentSize, (byte)indentChar, nl);
            }

            return Encoder.GetString(utf8.Span);
        }

        public static ReadOnlyMemory<byte> Prettify(
            ArrayBufferWriter<byte>? writer,
            ReadOnlyMemory<byte> utf8,
            int indentSize,
            byte indentChar,
            ReadOnlySpan<byte> newLine)
        {
            var span = utf8.Span;
            if (span.Length == 0)
            {
                return ReadOnlyMemory<byte>.Empty;
            }

            writer ??= new ArrayBufferWriter<byte>(initialCapacity: span.Length << 1);
            int written;

            int indentLevel = 0;
            int currentIndex = 0;

            do
            {
                switch (span[currentIndex])
                {
                    case (byte)'{':
                    case (byte)'[':
                        {
                            // for comparing with Json.NET, write empty in single line.
                            if (currentIndex + 1 < span.Length && span[currentIndex + 1] is (byte)']' or (byte)'}')
                            {
                                written = currentIndex + 1 + 1;
                                var buffer = writer.GetSpan(written);

                                buffer = CopySliceUnsafe(buffer, span.Slice(0, currentIndex));

                                // write both open and close
                                buffer = CopySliceUnsafe(buffer, span[currentIndex], 1);
                                currentIndex++;
                                /*buffer =*/
                                CopySliceUnsafe(buffer, span[currentIndex], 1);
                                currentIndex++;
                            }
                            else
                            {
                                indentLevel++;

                                written = currentIndex + 1 + newLine.Length + (indentSize * indentLevel);
                                var buffer = writer.GetSpan(written);

                                buffer = CopySliceUnsafe(buffer, span.Slice(0, currentIndex));
                                buffer = CopySliceUnsafe(buffer, span[currentIndex], 1);
                                currentIndex++;
                                buffer = CopySliceUnsafe(buffer, newLine);
                                /*buffer =*/
                                CopySliceUnsafe(buffer, indentChar, indentSize * indentLevel);
                            }
                        }
                        goto ADVANCE;

                    case (byte)':':
                        {
                            written = currentIndex + 1 + 1;
                            var buffer = writer.GetSpan(written);

                            currentIndex++;
                            buffer = CopySliceUnsafe(buffer, span.Slice(0, currentIndex));
                            /*buffer =*/
                            CopySliceUnsafe(buffer, (byte)' ', 1);
                        }
                        goto ADVANCE;

                    case (byte)',':
                        {
                            written = currentIndex + 1 + newLine.Length + (indentSize * indentLevel);
                            var buffer = writer.GetSpan(written);

                            currentIndex++;
                            buffer = CopySliceUnsafe(buffer, span.Slice(0, currentIndex));
                            buffer = CopySliceUnsafe(buffer, newLine);
                            /*buffer =*/
                            CopySliceUnsafe(buffer, indentChar, indentSize * indentLevel);
                        }
                        goto ADVANCE;

                    case (byte)'}':
                    case (byte)']':
                        {
                            indentLevel--;

                            written = currentIndex + newLine.Length + (indentSize * indentLevel) + 1;
                            var buffer = writer.GetSpan(written);

                            buffer = CopySliceUnsafe(buffer, span.Slice(0, currentIndex));
                            buffer = CopySliceUnsafe(buffer, newLine);
                            buffer = CopySliceUnsafe(buffer, indentChar, indentSize * indentLevel);
                            /*buffer =*/
                            CopySliceUnsafe(buffer, span[currentIndex], 1);
                            currentIndex++;
                        }
                        goto ADVANCE;

                    case (byte)'""':
                        {
                            currentIndex++;

                            // update both
                            currentIndex =
                            written = impl(currentIndex, span);

                            static int impl(int currentIndex, ReadOnlySpan<byte> span)
                            {
                                int originalIndex = currentIndex;

                                int found;
                                while ((found = span.Slice(currentIndex).IndexOf((byte)'""')) >= 0)
                                {
                                    found += currentIndex;
                                    currentIndex = found + 1;

                                    if (span[found - 1] == (byte)'\\')
                                    {
                                        continue;
                                    }
                                    return currentIndex;  // currentIndex is next char of '""'. return as is.
                                }
                                return originalIndex;
                            }
                        }
                        goto WRITE_AND_ADVANCE;

                    case (byte)'/':
                        {
                            currentIndex++;

                            // update both
                            currentIndex =
                            written = impl(currentIndex, span);

                            static int impl(int currentIndex, ReadOnlySpan<byte> span)
                            {
                                int originalIndex = currentIndex;

                                if (currentIndex >= span.Length)  // .Slice is allowed but indexer
                                {
                                    goto NOT_FOUND;
                                }

                                // block
                                if (span[currentIndex] == (byte)'*')
                                {
                                    currentIndex++;

                                    int found;
                                    while ((found = span.Slice(currentIndex).IndexOf((byte)'*')) >= 0)
                                    {
                                        found += currentIndex;
                                        currentIndex = found + 1;

                                        if (currentIndex == span.Length || span[currentIndex] != '/')
                                        {
                                            continue;
                                        }

                                        return currentIndex + 1;  // <-- currentIndex is '/'. +1 for written
                                    }

                                    goto NOT_FOUND;
                                }

                            // won't support single line comments

                            NOT_FOUND:
                                return originalIndex;
                            }
                        }
                        goto WRITE_AND_ADVANCE;

                    default:
                        {
                            currentIndex++;
                        }
                        goto CONTINUE;
                }

            WRITE_AND_ADVANCE:
                if (written <= 0)
                {
                    written = span.Length;
                }
                span.Slice(0, written).CopyTo(writer.GetSpan(written));

            ADVANCE:
                writer.Advance(written);
                span = span.Slice(currentIndex);
                currentIndex = 0;

            CONTINUE:
                ;
            }
            while (currentIndex < span.Length);

            written = span.Length;
            span.CopyTo(writer.GetSpan(written));
            writer.Advance(written);

            return writer.WrittenMemory;
        }

#endif
        #endregion


        /* NOTE: loop unrolling doesn't make sense on small data set

        ## x32 times on various data length (48 or more longer property names)

        | Method  | Mean     | Error   | StdDev  |
        |-------- |---------:|--------:|--------:|
        | Default | 262.3 ns | 2.25 ns | 1.88 ns |
        | Unroll4 | 266.8 ns | 3.82 ns | 3.39 ns |
        | Smart   | 264.5 ns | 4.13 ns | 3.86 ns |

        > Smart: use Default if data.Length < 12 otherwise use Unroll4

        */

        public static uint ComputeHash(ReadOnlySpan<byte> data)
        {
            // NOTE: for the reasoning, it's not required to compute complete hash for property names.
            //       instead just takes first N bytes. if collide, perform SequenceEqual to complete check.
            int len = data.Length;
            if (len >= 8)
            {
                // take middle of data
                // --> suffix style: MetadataFoo/Bar --> etadataF/etadataB
                // --> prefix style: Foo/BarMetadata --> ooMetada/arMetada
                var value = BinaryPrimitives.ReadUInt64LittleEndian(data.Slice((len - 8) >> 1));

                var hash = unchecked((uint)(value >> 32) ^ (uint)value);

                if (len >= 9)
                {
                    hash ^= BinaryPrimitives.ReadUInt32LittleEndian(data.Slice(len - 4));
                }

                if (len >= 10)
                {
                    hash ^= BinaryPrimitives.ReadUInt32LittleEndian(data);
                }

                return hash;
            }
            else
            {
                return len switch
                {
                    // 99% are suffix style: V0, Value1, TX, RY, SZ or etc.
                    >= 4 => BinaryPrimitives.ReadUInt32LittleEndian(data.Slice(len - 4)) ^ ((uint)data[0] << 24),  // XOR with last char (little endian)
                    >= 1 => data[len - 1],
                    _ => 0,
                };
            }

            /// <summary>
            /// Compute FNV-1a (32-bit) hash.
            /// </summary>
            /*
            static uint fnv_1a(ReadOnlySpan<byte> data)
            {
                const uint FNV_offset_basis = 2166136261;
                const uint FNV_prime = 16777619;

                uint hash = FNV_offset_basis;

                for (int i = 0; i < data.Length; i++)
                {
                    hash = (hash ^ data[i]) * FNV_prime;
                }

                return hash;
            }
            */
        }
    }
}
"
;
        public const string ToJsonHelpers
=
@"using System;
using System.Buffers;
using System.Buffers.Binary;
using System.Buffers.Text;

#nullable enable

namespace Jsonable
{
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true)]
    internal sealed class ToJsonAttribute : Attribute
    {
        public bool IncludeInternals { get; set; }
        public bool ExcludeInherited { get; set; }

        public bool PreservePropertyOrder { get; set; }
        public string? Property { get; set; }
    }

    internal static class ToJsonHelpers
    {
        public static bool TryWriteJsonableHeader<TWriter>(TWriter writer)
            where TWriter : IBufferWriter<byte>
        {
            var header = JSONABLE.ObjectHeader;
            var span = writer.GetSpan(header.Length);

            if (header.AsSpan().TryCopyTo(span))
            {
                writer.Advance(header.Length);
                return true;
            }
            else
            {
                return false;
            }
        }

        public static bool TryWriteJsonableMetadata<TWriter>(TWriter writer, int length)
            where TWriter : IBufferWriter<byte>
        {
            unchecked
            {
                var span = writer.GetSpan(6);

                if ((uint)length > JSONABLE.MetadataLengthMaxInclusive ||
                    span.Length < 6)
                {
                    return false;
                }

                JSONABLE.CommentOpen.AsSpan().CopyTo(span);
                BinaryPrimitives.WriteUInt16LittleEndian(span.Slice(2, 2), JSONABLE.EncodeLengthUnsafe(length));
                JSONABLE.CommentClose.AsSpan().CopyTo(span.Slice(4, 2));

                writer.Advance(6);
                return true;
            }
        }


        public static bool TryWriteNull<TWriter>(TWriter writer)
            where TWriter : IBufferWriter<byte>
        {
            var span = writer.GetSpan(4);

            if (JSONABLE.NULL.AsSpan().TryCopyTo(span))
            {
                writer.Advance(4);
                return true;
            }
            else
            {
                return false;
            }
        }

        public static bool TryWriteBoolean<TWriter>(TWriter writer, bool value)
            where TWriter : IBufferWriter<byte>
        {
            var span = writer.GetSpan(5);

            var tf = value ? JSONABLE.TRUE : JSONABLE.FALSE;
            if (tf.AsSpan().TryCopyTo(span))
            {
                writer.Advance(tf.Length);
                return true;
            }
            else
            {
                return false;
            }
        }

        public static bool TryWriteChar<TWriter>(TWriter writer, char value)
            where TWriter : IBufferWriter<byte>
        {
            var span = writer.GetSpan(1);
            if (span.Length != 0)
            {
                span[0] = (byte)value;
                writer.Advance(1);
                return true;
            }
            else
            {
                return false;
            }
        }


        public static bool TryWriteString<TWriter>(TWriter writer, string? value, bool needEscape, bool writeMetadata)
            where TWriter : IBufferWriter<byte>
        {
            if (value == null)
            {
                return TryWriteNull(writer);
            }

            if (needEscape)
            {
                value = JSONABLE.EscapeStringIfRequired(value);
            }

            int metadataLength = writeMetadata ? 6 : 0;
            int estimatedLength = (value.Length * 4) + 2 + metadataLength;  // UTF8 max possible bytes + quotes + metadata

            var span = writer.GetSpan(estimatedLength);
            if (span.Length < estimatedLength)
            {
                return false;
            }

            // first, write string to get actual utf8 bytes length
            int bytesWritten = 0;
            if (value.Length > 0)
            {
                bytesWritten = JSONABLE.Encoder.GetBytes(value, span.Slice(metadataLength + 1));  // metadata + leading quote
                if (bytesWritten == 0)
                {
                    return false;
                }
            }

            // then, write metadata
            if (writeMetadata)
            {
                if (!TryWriteJsonableMetadata(writer, bytesWritten))
                {
                    return false;
                }
            }

            // finally add quotes.
            span[metadataLength] = (byte)'""';
            bytesWritten += metadataLength + 1;  // metadata + leading quote

            span[bytesWritten] = (byte)'""';
            bytesWritten++;

            // NOTE: writing metadata will advance!
            writer.Advance(bytesWritten - metadataLength);
            return true;
        }

        public static bool TryWriteKey<TWriter>(TWriter writer, string value, bool needEscape, bool writeMetadata)
            where TWriter : IBufferWriter<byte>
        {
            if (!TryWriteString(writer, value, needEscape, writeMetadata))
            {
                return false;
            }

            var span = writer.GetSpan(1);
            if (span.Length == 0)
            {
                return false;
            }

            span[0] = (byte)':';

            writer.Advance(1);
            return true;
        }

        public static bool TryWriteKey<TWriter>(TWriter writer, bool writeMetadata, byte[] value)  // take byte[] to avoid conversion at caller site
            where TWriter : IBufferWriter<byte>
        {
            var len = value.Length;

            if (writeMetadata)
            {
                if (!TryWriteJsonableMetadata(writer, len))
                {
                    return false;
                }
            }

            var requiredLength = len + 3;  // quotes + ':'

            var span = writer.GetSpan(requiredLength);
            if (span.Length < requiredLength)
            {
                return false;
            }

            span[0] = (byte)'""';
            value.AsSpan().CopyTo(span.Slice(1));
            span[1 + len] = (byte)'""';
            span[2 + len] = (byte)':';

            writer.Advance(requiredLength);
            return true;
        }


        public static bool TryWriteBase64<TWriter>(TWriter writer, byte[] bytes, bool writeMetadata)  // Takes byte[] to reduce caller site code size
            where TWriter : IBufferWriter<byte>
        {
            int encodedLength = (bytes.Length + 2) / 3 * 4;

            if (writeMetadata)
            {
                if (!TryWriteJsonableMetadata(writer, encodedLength))
                {
                    return false;
                }
            }

            int requiredLength = encodedLength + 2;

            var span = writer.GetSpan(requiredLength);
            if (span.Length < requiredLength)
            {
                return false;
            }

            span[0] = (byte)'""';

            if (encodedLength > 0)
            {
                var status = Base64.EncodeToUtf8(bytes, span.Slice(1), out var _, out var written, isFinalBlock: true);
                if (status != OperationStatus.Done ||
                    encodedLength != written)  // not output.Length --> may be larger than requested size
                {
                    return false;
                }
            }

            span[1 + encodedLength] = (byte)'""';

            writer.Advance(requiredLength);
            return true;
        }


        public static bool TryCopyAndAdvance<TWriter>(TWriter writer, ReadOnlySpan<byte> value)
            where TWriter : IBufferWriter<byte>
        {
            if (value.Length == 0)
            {
                return true;
            }

            var span = writer.GetSpan(value.Length);

            if (value.TryCopyTo(span))
            {
                writer.Advance(value.Length);
                return true;
            }
            else
            {
                return false;
            }
        }
    }
}
"
;

    }
}
