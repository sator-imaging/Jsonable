using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;

namespace Jsonable.Core
{
    internal static class Utils
    {
        public static string GetPartialTypeDeclaration(INamedTypeSymbol typeSymbol)
        {
            string genericTypeParameters = string.Empty;
            if (typeSymbol.IsGenericType)
            {
                genericTypeParameters = $"<{string.Join(", ", typeSymbol.TypeParameters)}>";
            }

            if (typeSymbol.IsRecord)
            {
                return $"partial {(typeSymbol.IsValueType ? "record struct" : "record")} {typeSymbol.Name}{genericTypeParameters}";
            }
            else
            {
                return $"partial {(typeSymbol.IsValueType ? "struct" : "class")} {typeSymbol.Name}{genericTypeParameters}";
            }
        }

        public static string GetNamespaceDeclaration(INamedTypeSymbol typeSymbol)
        {
            if (typeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                return string.Empty;
            }

            return $"namespace {typeSymbol.ContainingNamespace.ToDisplayString()} {{";
        }

        public static string GetGenericAwareName(INamedTypeSymbol typeSymbol)
        {
            if (typeSymbol.IsGenericType)
            {
                return typeSymbol.Name + "T" + typeSymbol.TypeParameters.Length;
            }
            return typeSymbol.Name;
        }


        public static bool HasToJsonAttribute(AttributeData attribute)
        {
            return attribute.AttributeClass?.Name is "ToJson" or "ToJsonAttribute";
        }

        public static bool HasFromJsonAttribute(AttributeData attribute)
        {
            return attribute.AttributeClass?.Name is "FromJson" or "FromJsonAttribute";
        }


        public static bool IsEscapeRequired(string name)
        {
            return name.All(x => x is <= /*SPACE*/(char)0x20 or >= /*DEL*/(char)0x7F or '"' or '\\');
        }

        public static bool HasParameterlessConstructor(ITypeSymbol typeSymbol)
        {
            return typeSymbol is INamedTypeSymbol namedTypeSymbol
                && namedTypeSymbol.Constructors.Any(c =>
                    c.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal &&
                    c.Parameters.Length == 0);
        }


        public static string GenerateSourceCodeWithHeader(StringBuilder sb, int totalPropertyCount, int generatedPropertyCount)
        {
            return
$@"// <auto-generated>
//   {nameof(JsonableSourceGenerator)}
//   --> Total {generatedPropertyCount} properties generated (failed: {totalPropertyCount - generatedPropertyCount})
// </auto-generated>
"
                + sb.ToString();
        }

        public static string GenerateCSharpDirectives()
        {
            return
@"
#pragma warning disable CS0168  // The variable 'var' is declared but never used
#pragma warning disable CS0162  // Unreachable code detected
#pragma warning disable CS1591  // Missing XML comment for publicly visible type or member

using System;
using System.Buffers;
using System.Buffers.Text;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;

#nullable enable
";
        }


        public static StringBuilder GetStringBuilder(int propertyCount)
        {
            return new StringBuilder(capacity: Math.Min(65536, 1024 + (propertyCount * 256)));
        }


        public static (bool includeInternals, bool excludeInherited, ImmutableDictionary<string, object> extraData)
            GetAttributeConfiguration(SemanticModel semanticModel, AttributeSyntax attributeSyntax, params string[] extraPropertyNames)
        {
            bool includeInternals = false;
            bool excludeInherited = false;
            var extraData = ImmutableDictionary<string, object>.Empty;

            if (attributeSyntax.ArgumentList != null)
            {
                foreach (var argument in attributeSyntax.ArgumentList.Arguments)
                {
                    if (argument.NameEquals == null)
                    {
                        continue;
                    }

                    string argumentName = argument.NameEquals.Name.Identifier.Text;
                    var constantValue = semanticModel.GetConstantValue(argument.Expression);

                    if (!constantValue.HasValue)
                    {
                        continue;
                    }

                    if (constantValue.Value is bool boolValue)
                    {
                        if (argumentName == "IncludeInternals")
                        {
                            includeInternals = boolValue;
                        }
                        else if (argumentName == "ExcludeInherited")
                        {
                            excludeInherited = boolValue;
                        }
                    }
                    else
                    {
                        if (extraPropertyNames.Contains(argumentName))
                        {
                            extraData = extraData.Add(argumentName, (((constantValue.Value!))));
                        }
                    }
                }
            }

            return (includeInternals, excludeInherited, extraData);
        }


        public static bool IsKeyValuePairCollection(
            ITypeSymbol typeSymbol,
            GeneratorExecutionContext context,
            [NotNullWhen(true)] out ITypeSymbol? keyType,
            [NotNullWhen(true)] out ITypeSymbol? valueType)
        {
            keyType = null;
            valueType = null;

            INamedTypeSymbol? keyValuePairT = context.Compilation.GetTypeByMetadataName("System.Collections.Generic.KeyValuePair`2");
            if (keyValuePairT == null)
            {
                return false;
            }

            // Check if the type itself is ICollection<KeyValuePair<TKey, TValue>>
            if (typeSymbol is INamedTypeSymbol namedTypeSymbol &&
                namedTypeSymbol.ConstructedFrom.SpecialType == SpecialType.System_Collections_Generic_ICollection_T &&
                namedTypeSymbol.TypeArguments.Length == 1 &&
                namedTypeSymbol.TypeArguments[0] is INamedTypeSymbol kvpArgSymbol &&
                SymbolEqualityComparer.Default.Equals(kvpArgSymbol.ConstructedFrom, keyValuePairT))
            {
                keyType = kvpArgSymbol.TypeArguments[0];
                valueType = kvpArgSymbol.TypeArguments[1];
                return true;
            }

            // Check if the type implements ICollection<KeyValuePair<TKey, TValue>>
            else if (
                typeSymbol is INamedTypeSymbol namedTypeSymbol2 && namedTypeSymbol2.AllInterfaces.FirstOrDefault(i =>
                    i.ConstructedFrom.SpecialType == SpecialType.System_Collections_Generic_ICollection_T &&
                    i.TypeArguments.Length == 1 &&
                    i.TypeArguments[0] is INamedTypeSymbol kvpInterfaceArgSymbol &&
                    SymbolEqualityComparer.Default.Equals(kvpInterfaceArgSymbol.ConstructedFrom, keyValuePairT)
                )?.TypeArguments[0] is INamedTypeSymbol kvpInterfaceArgSymbol)
            {
                keyType = kvpInterfaceArgSymbol.TypeArguments[0];
                valueType = kvpInterfaceArgSymbol.TypeArguments[1];
                return true;
            }

            return false;
        }
    }
}
